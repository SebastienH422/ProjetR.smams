---
title: "Graphiques"
output: html_document
date: "2024-12-17"
---
#Importation de toutes les librairies
```{r setup, include=FALSE}
library(data.table)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(RColorBrewer)
#install.packages("wordcloud2")
library(wordcloud2)
library(data.table)
#install.packages("wordcloud")
library(wordcloud)
#install.packages("plotly")
library(plotly)
#install.packages("treemap")
library(treemap)
#install.packages("ggridges")
library(ggridges)
library(cluster)
```

#Importation data table
```{r cars}
setwd('/net/cremi/mboivent/Bureau/espaces/travail/S7/R/projet/ProjetR.smams-main')
base_emp_inno = fread("Data/base_emp_inno.csv")
```


#Distribution des salaires par département et niveau d'innovation
Attention !!! Très peu d'entreprises prises en compte !!!!!
Message d'avis :
Removed 132 rows containing missing values or values outside the scale range
(`geom_col()`). 
```{r pressure, echo=FALSE}
base_emp_inno = fread("Data/base_emp_inno.csv")
base_emp_inno[,brevet_categorie := cut(
  n_patents,
  breaks = c(-Inf, 5, 10, 15, Inf),
  labels = c("Faible", "Moyen", "Élevé", "Très élevé")
)]

ggplot(base_emp_inno, aes(x = factor(addr_dept_main), y = avg_wage, fill = brevet_categorie)) +
  geom_col() +
  scale_fill_manual(
    values = c(
      "Faible" = "#e8a2fa",  
      "Moyen" = "#c471d1",  
      "Élevé" = "#8543e0",  
      "Très élevé" = "#314bde"   
    )
  ) +  # Palette pour catégories
  labs(
    title = "Distribution des salaires par département et niveau d'innovation",
    x = "Département principal",
    y = "Salaire proposé",
    fill = "Catégorie de brevets"
  ) +
  theme_minimal()
```

#Relation entre le salaire et le nombre de brevets
Fonctionne mais il n'y a que 22 entreprises
Graphique intéractif
```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
p <- ggplot(base_emp_inno, aes(x = avg_wage, y = n_patents, color = avg_wage, size = n_patents)) +
  geom_point(alpha = 0.7) +  # Points semi-transparents
  scale_color_gradient(low = "#f5dd00", high ="#f50000",limits = c(0, 80000)) +  # Couleurs jaunes
  scale_y_continuous(limits = c(0, 20)) +  # Limites de l'axe des ordonnées
  scale_x_continuous(limits = c(0, 80000)) +
  labs(
    title = "Relation entre le salaire et le nombre de brevets",
    x = "Salaire (en euros par mois)",
    y = "Nombre de brevets",
    color = "Salaire",
    size = "Nombre de brevets"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p <- p + coord_cartesian(xlim = c(0, 80000), ylim = c(0, 20))

# Convertir en graphique interactif avec plotly
interactive_plot <- ggplotly(p)

# Afficher le graphique interactif
interactive_plot
```




#INOVATION EN FONCTION DU nb d'offres d'emploi"
```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
# Ajouter une ligne de régression en jaune
ggplot(base_emp_inno, aes(x = n_offres, y = n_patents)) +
  geom_point(aes(color = n_offres), size = 1) +  # Points colorés en fonction du nb d'offres d'emploi
  scale_color_gradient(low = "#f9d1c9", high = "#f70254") +  # Échelle de jaune
  #geom_smooth(method = "lm", se = FALSE, color = "#b4476b") +  # Ligne de régression en jaune
  labs(
    title = "Nombre de brevets en fonction du nb d'offres d'emploi",
    x = "nb d'offres d'emploi",
    y = "Nombre de brevets",
    color = "Salaire"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```


# INOVATION EN FONCTION DU SALAIRE
Une trentaine d'entreprises
```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
ggplot(base_emp_inno[!is.null(avg_wage) & !is.na(avg_wage) & avg_wage < 200000], aes(x = avg_wage, y = n_patents)) +
  geom_point(aes(color = avg_wage), size = 2) +  # Points colorés en fonction du salaire
  scale_color_gradient(low = "#ffe87e", high = "#f78d02") +  # Échelle de jaune
  geom_smooth(method = "lm", se = FALSE, color = "goldenrod") +  # Ligne de régression en jaune
  labs(
    title = "Nombre de brevets en fonction du salaire avec régression",
    x = "Salaire (en euros par mois)",
    y = "Nombre de brevets",
    color = "Salaire"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```


#Wordcloud des secteurs pondérés par le salaire
```{r}
# Définir le nombre de colonnes de la matrice
n_colonnes <- 5

# Initialiser une matrice vide avec le bon nombre de lignes et colonnes
matrice <- matrix(NA, nrow = nrow(base_emp_inno), ncol = n_colonnes)

# Remplir la matrice ligne par ligne
for (i in 1:nrow(base_emp_inno)) {
  # Extraire les mots en utilisant la virgule comme séparateur
  mots <- unlist(strsplit(base_emp_inno$sector_main[i], split = ",\\s*"))
  
  # Vérifier si mots n'est pas vide avant d'affecter les valeurs
  if (length(mots) > 0) {
    matrice[i, 1:min(length(mots), n_colonnes)] <- mots[1:min(length(mots), n_colonnes)]
  }
}

# Afficher la matrice
print(matrice)
# Extraire la première colonne de la matrice
vecteur_premiere_colonne <- matrice[, 1]

# Afficher le vecteur
print(vecteur_premiere_colonne)

vecteur_premiere_colonne_sans_na <- vecteur_premiere_colonne[!is.na(vecteur_premiere_colonne)]

# Afficher le vecteur
print(vecteur_premiere_colonne_sans_na)

# Garder uniquement les valeurs uniques dans le vecteur
vecteur_premiere_colonne_sans_doublons <- unique(vecteur_premiere_colonne_sans_na)

# Afficher le nouveau vecteur sans doublons
print(vecteur_premiere_colonne_sans_doublons)

# Créer un vecteur de pondération de la même longueur que le vecteur unique
ponderation <- rep(1, length(vecteur_premiere_colonne_sans_doublons))

# Afficher le vecteur de pondération
print(ponderation)

# Ajouter une colonne contenant les firm_name
matrice <- cbind(matrice, base_emp_inno$firm_name)

# Afficher la nouvelle matrice
print(matrice)

# Créer une matrice avec deux colonnes
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne avec des 0
)

# Afficher la matrice
print(matrice_resultante)

matrice <- cbind(matrice, base_emp_inno$avg_wage)

# Afficher la nouvelle matrice
print(matrice)

# Première colonne unique sans doublons
vecteur_premiere_colonne_sans_doublons <- unique(na.omit(as.vector(matrice[, 1:5])))

# Créer matrice_resultante avec des 0 dans la deuxième colonne
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne initialisée à 0
)

# Parcourir chaque ligne de la matrice pour additionner les valeurs correspondantes
for (i in 1:nrow(matrice)) {
  # Obtenir la valeur à ajouter (dernière colonne de la ligne courante)
  valeur_a_ajouter <- as.numeric(matrice[i, ncol(matrice)])
  
  # Vérifier si la valeur n'est pas NA
  if (!is.na(valeur_a_ajouter)) {
    # Parcourir les colonnes 1 à 5 de la ligne courante
    for (j in 1:(ncol(matrice) - 1)) {
      mot <- matrice[i, j]
      # Si le mot n'est pas NA, ajouter la valeur dans matrice_resultante
      if (!is.na(mot)) {
        # Trouver l'index de la ligne dans matrice_resultante où le mot se trouve
        index <- which(matrice_resultante[, 1] == mot)
        if (length(index) > 0) {
          # Ajouter la valeur à la deuxième colonne
          matrice_resultante[index, 2] <- as.numeric(matrice_resultante[index, 2]) + valeur_a_ajouter
        }
      }
    }
  }
}

# Afficher la matrice finale
print(matrice_resultante)

# Extraire les données de la matrice_resultante
mots <- matrice_resultante[, 1]  # Première colonne : mots
ponderations <- as.numeric(matrice_resultante[, 2])  # Deuxième colonne : pondérations

# Définir vos propres couleurs
couleur_claire <- "#75a7e0"  # Vert clair (par exemple)
couleur_foncee <- "#0c54fa"  # Vert foncé (par exemple)

# Créer une palette de dégradé entre ces deux couleurs
palette_personnalisee <- colorRampPalette(c(couleur_claire, couleur_foncee))

# Créer le Word Cloud
wordcloud(words = mots, 
          freq = ponderations, 
          min.freq = 1,                     # Fréquence minimale
          scale = c(3, 0.5),                # Réduire la taille max et min des mots
          random.order = FALSE,             # Les mots les plus fréquents sont centrés
          colors = palette_personnalisee(5)) # Générer 8 nuances entre vos deux couleurs

```

#Wordcloud des secteurs pondérés par les brevets
```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
# Définir le nombre de colonnes de la matrice
n_colonnes <- 5

# Initialiser une matrice vide avec le bon nombre de lignes et colonnes
matrice <- matrix(NA, nrow = nrow(base_emp_inno), ncol = n_colonnes)

# Remplir la matrice ligne par ligne
for (i in 1:nrow(base_emp_inno)) {
  # Extraire les mots en utilisant la virgule comme séparateur
  mots <- unlist(strsplit(base_emp_inno$sector_main[i], split = ",\\s*"))
  
  # Vérifier si mots n'est pas vide avant d'affecter les valeurs
  if (length(mots) > 0) {
    matrice[i, 1:min(length(mots), n_colonnes)] <- mots[1:min(length(mots), n_colonnes)]
  }
}

# Afficher la matrice
print(matrice)
# Extraire la première colonne de la matrice
vecteur_premiere_colonne <- matrice[, 1]

# Afficher le vecteur
print(vecteur_premiere_colonne)

vecteur_premiere_colonne_sans_na <- vecteur_premiere_colonne[!is.na(vecteur_premiere_colonne)]

# Afficher le vecteur
print(vecteur_premiere_colonne_sans_na)

# Garder uniquement les valeurs uniques dans le vecteur
vecteur_premiere_colonne_sans_doublons <- unique(vecteur_premiere_colonne_sans_na)

# Afficher le nouveau vecteur sans doublons
print(vecteur_premiere_colonne_sans_doublons)

# Créer un vecteur de pondération de la même longueur que le vecteur unique
ponderation <- rep(1, length(vecteur_premiere_colonne_sans_doublons))

# Afficher le vecteur de pondération
print(ponderation)

# Ajouter une colonne contenant les firm_name
matrice <- cbind(matrice, base_emp_inno$firm_name)

# Afficher la nouvelle matrice
print(matrice)

# Créer une matrice avec deux colonnes
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne avec des 0
)

# Afficher la matrice
print(matrice_resultante)

matrice <- cbind(matrice, base_emp_inno$n_patents)

# Afficher la nouvelle matrice
print(matrice)

# Première colonne unique sans doublons
vecteur_premiere_colonne_sans_doublons <- unique(na.omit(as.vector(matrice[, 1:5])))

# Créer matrice_resultante avec des 0 dans la deuxième colonne
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne initialisée à 0
)

# Parcourir chaque ligne de la matrice pour additionner les valeurs correspondantes
for (i in 1:nrow(matrice)) {
  # Obtenir la valeur à ajouter (dernière colonne de la ligne courante)
  valeur_a_ajouter <- as.numeric(matrice[i, ncol(matrice)])
  
  # Vérifier si la valeur n'est pas NA
  if (!is.na(valeur_a_ajouter)) {
    # Parcourir les colonnes 1 à 5 de la ligne courante
    for (j in 1:(ncol(matrice) - 1)) {
      mot <- matrice[i, j]
      # Si le mot n'est pas NA, ajouter la valeur dans matrice_resultante
      if (!is.na(mot)) {
        # Trouver l'index de la ligne dans matrice_resultante où le mot se trouve
        index <- which(matrice_resultante[, 1] == mot)
        if (length(index) > 0) {
          # Ajouter la valeur à la deuxième colonne
          matrice_resultante[index, 2] <- as.numeric(matrice_resultante[index, 2]) + valeur_a_ajouter
        }
      }
    }
  }
}

# Afficher la matrice finale
print(matrice_resultante)

# Extraire les données de la matrice_resultante
mots <- matrice_resultante[, 1]  # Première colonne : mots
ponderations <- as.numeric(matrice_resultante[, 2])  # Deuxième colonne : pondérations

# Définir vos propres couleurs
couleur_claire <- "#75a7e0"  # Vert clair (par exemple)
couleur_foncee <- "#0c54fa"  # Vert foncé (par exemple)

# Créer une palette de dégradé entre ces deux couleurs
palette_personnalisee <- colorRampPalette(c(couleur_claire, couleur_foncee))

# Créer le Word Cloud
wordcloud(words = mots, 
          freq = ponderations, 
          min.freq = 1,                     # Fréquence minimale
          scale = c(3, 0.5),                # Réduire la taille max et min des mots
          random.order = FALSE,             # Les mots les plus fréquents sont centrés
          colors = palette_personnalisee(5)) # Générer 8 nuances entre vos deux couleurs
```


#Wordcloud des compétences pondérées par le salaire
```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
# Définir le nombre de colonnes de la matrice
n_colonnes <- 10

# Initialiser une matrice vide avec le bon nombre de lignes et colonnes
matrice <- matrix(NA, nrow = nrow(base_emp_inno), ncol = n_colonnes)

# Remplir la matrice ligne par ligne
for (i in 1:nrow(base_emp_inno)) {
  # Extraire les mots en utilisant la virgule comme séparateur
  mots <- unlist(strsplit(base_emp_inno$top_skill_req[i], split = ",\\s*"))
  
  # Vérifier si mots n'est pas vide avant d'affecter les valeurs
  if (length(mots) > 0) {
    matrice[i, 1:min(length(mots), n_colonnes)] <- mots[1:min(length(mots), n_colonnes)]
  }
}

# Afficher la matrice
print(matrice)
# Extraire la première colonne de la matrice
vecteur_premiere_colonne <- matrice[, 1]

# Afficher le vecteur
print(vecteur_premiere_colonne)

vecteur_premiere_colonne_sans_na <- vecteur_premiere_colonne[!is.na(vecteur_premiere_colonne)]

# Afficher le vecteur
print(vecteur_premiere_colonne_sans_na)

# Garder uniquement les valeurs uniques dans le vecteur
vecteur_premiere_colonne_sans_doublons <- unique(vecteur_premiere_colonne_sans_na)

# Afficher le nouveau vecteur sans doublons
print(vecteur_premiere_colonne_sans_doublons)

# Créer un vecteur de pondération de la même longueur que le vecteur unique
ponderation <- rep(1, length(vecteur_premiere_colonne_sans_doublons))

# Afficher le vecteur de pondération
print(ponderation)

# Ajouter une colonne contenant les firm_name
matrice <- cbind(matrice, base_emp_inno$firm_name)

# Afficher la nouvelle matrice
print(matrice)

# Créer une matrice avec deux colonnes
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne avec des 0
)

# Afficher la matrice
print(matrice_resultante)

matrice <- cbind(matrice, base_emp_inno$avg_wage)

# Afficher la nouvelle matrice
print(matrice)

# Première colonne unique sans doublons
vecteur_premiere_colonne_sans_doublons <- unique(na.omit(as.vector(matrice[, 1:5])))

# Créer matrice_resultante avec des 0 dans la deuxième colonne
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne initialisée à 0
)

# Parcourir chaque ligne de la matrice pour additionner les valeurs correspondantes
for (i in 1:nrow(matrice)) {
  # Obtenir la valeur à ajouter (dernière colonne de la ligne courante)
  valeur_a_ajouter <- as.numeric(matrice[i, ncol(matrice)])
  
  # Vérifier si la valeur n'est pas NA
  if (!is.na(valeur_a_ajouter)) {
    # Parcourir les colonnes 1 à 5 de la ligne courante
    for (j in 1:(ncol(matrice) - 1)) {
      mot <- matrice[i, j]
      # Si le mot n'est pas NA, ajouter la valeur dans matrice_resultante
      if (!is.na(mot)) {
        # Trouver l'index de la ligne dans matrice_resultante où le mot se trouve
        index <- which(matrice_resultante[, 1] == mot)
        if (length(index) > 0) {
          # Ajouter la valeur à la deuxième colonne
          matrice_resultante[index, 2] <- as.numeric(matrice_resultante[index, 2]) + valeur_a_ajouter
        }
      }
    }
  }
}

# Afficher la matrice finale
print(matrice_resultante)

# Extraire les données de la matrice_resultante
mots <- matrice_resultante[, 1]  # Première colonne : mots
ponderations <- as.numeric(matrice_resultante[, 2])  # Deuxième colonne : pondérations

# Définir vos propres couleurs
couleur_claire <- "#97bf95"  # Vert clair (par exemple)
couleur_foncee <- "#1b5e20"  # Vert foncé (par exemple)

# Créer une palette de dégradé entre ces deux couleurs
palette_personnalisee <- colorRampPalette(c(couleur_claire, couleur_foncee))

# Créer le Word Cloud
wordcloud(words = mots, 
          freq = ponderations, 
          min.freq = 1,                     # Fréquence minimale
          scale = c(3, 0.5),                # Réduire la taille max et min des mots
          random.order = FALSE,             # Les mots les plus fréquents sont centrés
          colors = palette_personnalisee(8)) # Générer 8 nuances entre vos deux couleurs

```


#Wordcloud des compétences pondérées par les brevets

```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
# Définir le nombre de colonnes de la matrice
n_colonnes <- 10

# Initialiser une matrice vide avec le bon nombre de lignes et colonnes
matrice <- matrix(NA, nrow = nrow(base_emp_inno), ncol = n_colonnes)

# Remplir la matrice ligne par ligne
for (i in 1:nrow(base_emp_inno)) {
  # Extraire les mots en utilisant la virgule comme séparateur
  mots <- unlist(strsplit(base_emp_inno$top_skill_req[i], split = ",\\s*"))
  
  # Vérifier si mots n'est pas vide avant d'affecter les valeurs
  if (length(mots) > 0) {
    matrice[i, 1:min(length(mots), n_colonnes)] <- mots[1:min(length(mots), n_colonnes)]
  }
}

# Afficher la matrice
print(matrice)
# Extraire la première colonne de la matrice
vecteur_premiere_colonne <- matrice[, 1]

# Afficher le vecteur
print(vecteur_premiere_colonne)

vecteur_premiere_colonne_sans_na <- vecteur_premiere_colonne[!is.na(vecteur_premiere_colonne)]

# Afficher le vecteur
print(vecteur_premiere_colonne_sans_na)

# Garder uniquement les valeurs uniques dans le vecteur
vecteur_premiere_colonne_sans_doublons <- unique(vecteur_premiere_colonne_sans_na)

# Afficher le nouveau vecteur sans doublons
print(vecteur_premiere_colonne_sans_doublons)

# Créer un vecteur de pondération de la même longueur que le vecteur unique
ponderation <- rep(1, length(vecteur_premiere_colonne_sans_doublons))

# Afficher le vecteur de pondération
print(ponderation)

# Ajouter une colonne contenant les firm_name
matrice <- cbind(matrice, base_emp_inno$firm_name)

# Afficher la nouvelle matrice
print(matrice)

# Créer une matrice avec deux colonnes
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne avec des 0
)

# Afficher la matrice
print(matrice_resultante)

matrice <- cbind(matrice, base_emp_inno$n_patents)

# Afficher la nouvelle matrice
print(matrice)

# Première colonne unique sans doublons
vecteur_premiere_colonne_sans_doublons <- unique(na.omit(as.vector(matrice[, 1:5])))

# Créer matrice_resultante avec des 0 dans la deuxième colonne
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne initialisée à 0
)

# Parcourir chaque ligne de la matrice pour additionner les valeurs correspondantes
for (i in 1:nrow(matrice)) {
  # Obtenir la valeur à ajouter (dernière colonne de la ligne courante)
  valeur_a_ajouter <- as.numeric(matrice[i, ncol(matrice)])
  
  # Vérifier si la valeur n'est pas NA
  if (!is.na(valeur_a_ajouter)) {
    # Parcourir les colonnes 1 à 5 de la ligne courante
    for (j in 1:(ncol(matrice) - 1)) {
      mot <- matrice[i, j]
      # Si le mot n'est pas NA, ajouter la valeur dans matrice_resultante
      if (!is.na(mot)) {
        # Trouver l'index de la ligne dans matrice_resultante où le mot se trouve
        index <- which(matrice_resultante[, 1] == mot)
        if (length(index) > 0) {
          # Ajouter la valeur à la deuxième colonne
          matrice_resultante[index, 2] <- as.numeric(matrice_resultante[index, 2]) + valeur_a_ajouter
        }
      }
    }
  }
}

# Afficher la matrice finale
print(matrice_resultante)

# Extraire les données de la matrice_resultante
mots <- matrice_resultante[, 1]  # Première colonne : mots
ponderations <- as.numeric(matrice_resultante[, 2])  # Deuxième colonne : pondérations

# Définir vos propres couleurs
couleur_claire <- "#97bf95"  # Vert clair (par exemple)
couleur_foncee <- "#1b5e20"  # Vert foncé (par exemple)

# Créer une palette de dégradé entre ces deux couleurs
palette_personnalisee <- colorRampPalette(c(couleur_claire, couleur_foncee))

# Créer le Word Cloud
wordcloud(words = mots, 
          freq = ponderations, 
          min.freq = 1,                     # Fréquence minimale
          scale = c(3, 0.5),                # Réduire la taille max et min des mots
          random.order = FALSE,             # Les mots les plus fréquents sont centrés
          colors = palette_personnalisee(8) # Générer 8 nuances entre vos deux couleurs
)

```



#Wordcloud des villes pondérées par le salaire
```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
# Définir le nombre de colonnes de la matrice
n_colonnes <- 10

# Initialiser une matrice vide avec le bon nombre de lignes et colonnes
matrice <- matrix(NA, nrow = nrow(base_emp_inno), ncol = n_colonnes)

# Remplir la matrice ligne par ligne
for (i in 1:nrow(base_emp_inno)) {
  # Extraire les mots en utilisant la virgule comme séparateur
  mots <- unlist(strsplit(base_emp_inno$addr_city_main[i], split = ",\\s*"))
  
  # Vérifier si mots n'est pas vide avant d'affecter les valeurs
  if (length(mots) > 0) {
    matrice[i, 1:min(length(mots), n_colonnes)] <- mots[1:min(length(mots), n_colonnes)]
  }
}

# Afficher la matrice
print(matrice)
# Extraire la première colonne de la matrice
vecteur_premiere_colonne <- matrice[, 1]

# Afficher le vecteur
print(vecteur_premiere_colonne)

vecteur_premiere_colonne_sans_na <- vecteur_premiere_colonne[!is.na(vecteur_premiere_colonne)]

# Afficher le vecteur
print(vecteur_premiere_colonne_sans_na)

# Garder uniquement les valeurs uniques dans le vecteur
vecteur_premiere_colonne_sans_doublons <- unique(vecteur_premiere_colonne_sans_na)

# Afficher le nouveau vecteur sans doublons
print(vecteur_premiere_colonne_sans_doublons)

# Créer un vecteur de pondération de la même longueur que le vecteur unique
ponderation <- rep(1, length(vecteur_premiere_colonne_sans_doublons))

# Afficher le vecteur de pondération
print(ponderation)

# Ajouter une colonne contenant les firm_name
matrice <- cbind(matrice, base_emp_inno$firm_name)

# Afficher la nouvelle matrice
print(matrice)

# Créer une matrice avec deux colonnes
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne avec des 0
)

# Afficher la matrice
print(matrice_resultante)

matrice <- cbind(matrice, base_emp_inno$avg_wage)

# Afficher la nouvelle matrice
print(matrice)

# Première colonne unique sans doublons
vecteur_premiere_colonne_sans_doublons <- unique(na.omit(as.vector(matrice[, 1:5])))

# Créer matrice_resultante avec des 0 dans la deuxième colonne
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne initialisée à 0
)

# Parcourir chaque ligne de la matrice pour additionner les valeurs correspondantes
for (i in 1:nrow(matrice)) {
  # Obtenir la valeur à ajouter (dernière colonne de la ligne courante)
  valeur_a_ajouter <- as.numeric(matrice[i, ncol(matrice)])
  
  # Vérifier si la valeur n'est pas NA
  if (!is.na(valeur_a_ajouter)) {
    # Parcourir les colonnes 1 à 5 de la ligne courante
    for (j in 1:(ncol(matrice) - 1)) {
      mot <- matrice[i, j]
      # Si le mot n'est pas NA, ajouter la valeur dans matrice_resultante
      if (!is.na(mot)) {
        # Trouver l'index de la ligne dans matrice_resultante où le mot se trouve
        index <- which(matrice_resultante[, 1] == mot)
        if (length(index) > 0) {
          # Ajouter la valeur à la deuxième colonne
          matrice_resultante[index, 2] <- as.numeric(matrice_resultante[index, 2]) + valeur_a_ajouter
        }
      }
    }
  }
}

# Afficher la matrice finale
print(matrice_resultante)

# Extraire les données de la matrice_resultante
mots <- matrice_resultante[, 1]  # Première colonne : mots
ponderations <- as.numeric(matrice_resultante[, 2])  # Deuxième colonne : pondérations

# Définir vos propres couleurs
couleur_claire <- "#f7b457"  # Vert clair (par exemple)
couleur_foncee <- "#ff3700"  # Vert foncé (par exemple)

# Créer une palette de dégradé entre ces deux couleurs
palette_personnalisee <- colorRampPalette(c(couleur_claire, couleur_foncee))

# Créer le Word Cloud
wordcloud(words = mots, 
          freq = ponderations, 
          min.freq = 1,                     # Fréquence minimale
          scale = c(3, 0.5),                # Réduire la taille max et min des mots
          random.order = FALSE,             # Les mots les plus fréquents sont centrés
          colors = palette_personnalisee(8)) # Générer 8 nuances entre vos deux couleurs

```


#Wordcloud des villes pondérées par les brevets
```{r}
base_emp_inno = fread("Data/base_emp_inno.csv")
# Définir le nombre de colonnes de la matrice
n_colonnes <- 10

# Initialiser une matrice vide avec le bon nombre de lignes et colonnes
matrice <- matrix(NA, nrow = nrow(base_emp_inno), ncol = n_colonnes)

# Remplir la matrice ligne par ligne
for (i in 1:nrow(base_emp_inno)) {
  # Extraire les mots en utilisant la virgule comme séparateur
  mots <- unlist(strsplit(base_emp_inno$addr_city_main[i], split = ",\\s*"))
  
  # Vérifier si mots n'est pas vide avant d'affecter les valeurs
  if (length(mots) > 0) {
    matrice[i, 1:min(length(mots), n_colonnes)] <- mots[1:min(length(mots), n_colonnes)]
  }
}

# Afficher la matrice
print(matrice)
# Extraire la première colonne de la matrice
vecteur_premiere_colonne <- matrice[, 1]

# Afficher le vecteur
print(vecteur_premiere_colonne)

vecteur_premiere_colonne_sans_na <- vecteur_premiere_colonne[!is.na(vecteur_premiere_colonne)]

# Afficher le vecteur
print(vecteur_premiere_colonne_sans_na)

# Garder uniquement les valeurs uniques dans le vecteur
vecteur_premiere_colonne_sans_doublons <- unique(vecteur_premiere_colonne_sans_na)

# Afficher le nouveau vecteur sans doublons
print(vecteur_premiere_colonne_sans_doublons)

# Créer un vecteur de pondération de la même longueur que le vecteur unique
ponderation <- rep(1, length(vecteur_premiere_colonne_sans_doublons))

# Afficher le vecteur de pondération
print(ponderation)

# Ajouter une colonne contenant les firm_name
matrice <- cbind(matrice, base_emp_inno$firm_name)

# Afficher la nouvelle matrice
print(matrice)

# Créer une matrice avec deux colonnes
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne avec des 0
)

# Afficher la matrice
print(matrice_resultante)

matrice <- cbind(matrice, base_emp_inno$n_patents)

# Afficher la nouvelle matrice
print(matrice)

# Première colonne unique sans doublons
vecteur_premiere_colonne_sans_doublons <- unique(na.omit(as.vector(matrice[, 1:5])))

# Créer matrice_resultante avec des 0 dans la deuxième colonne
matrice_resultante <- cbind(
  vecteur_premiere_colonne_sans_doublons,  # Première colonne
  rep(0, length(vecteur_premiere_colonne_sans_doublons))  # Deuxième colonne initialisée à 0
)

# Parcourir chaque ligne de la matrice pour additionner les valeurs correspondantes
for (i in 1:nrow(matrice)) {
  # Obtenir la valeur à ajouter (dernière colonne de la ligne courante)
  valeur_a_ajouter <- as.numeric(matrice[i, ncol(matrice)])
  
  # Vérifier si la valeur n'est pas NA
  if (!is.na(valeur_a_ajouter)) {
    # Parcourir les colonnes 1 à 5 de la ligne courante
    for (j in 1:(ncol(matrice) - 1)) {
      mot <- matrice[i, j]
      # Si le mot n'est pas NA, ajouter la valeur dans matrice_resultante
      if (!is.na(mot)) {
        # Trouver l'index de la ligne dans matrice_resultante où le mot se trouve
        index <- which(matrice_resultante[, 1] == mot)
        if (length(index) > 0) {
          # Ajouter la valeur à la deuxième colonne
          matrice_resultante[index, 2] <- as.numeric(matrice_resultante[index, 2]) + valeur_a_ajouter
        }
      }
    }
  }
}

# Afficher la matrice finale
print(matrice_resultante)

# Extraire les données de la matrice_resultante
mots <- matrice_resultante[, 1]  # Première colonne : mots
ponderations <- as.numeric(matrice_resultante[, 2])  # Deuxième colonne : pondérations

# Définir vos propres couleurs
couleur_claire <- "#f7b457"  # Vert clair (par exemple)
couleur_foncee <- "#ff3700"  # Vert foncé (par exemple)

# Créer une palette de dégradé entre ces deux couleurs
palette_personnalisee <- colorRampPalette(c(couleur_claire, couleur_foncee))

# Créer le Word Cloud
wordcloud(words = mots, 
          freq = ponderations, 
          min.freq = 1,                     # Fréquence minimale
          scale = c(3, 0.5),                # Réduire la taille max et min des mots
          random.order = FALSE,             # Les mots les plus fréquents sont centrés
          colors = palette_personnalisee(8)) # Générer 8 nuances entre vos deux couleurs

```


















