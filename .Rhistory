addr_dept_main = get_top_val(departement, 1),  # Most common department
top_skill_req = get_top_val(competences_requises, 4)  # Top 4 most frequent skills
), by = entreprise]
# Remove the "entreprise" column and rename grouped by "firm_name"
base_emp[, entreprise := NULL]
# Print the final grouped results
View(base_emp)
test_salaries <- c("50K", "20 000", "30k par mois", "15000-20000", "200 par jour", "", NA, "invalid text")
sapply(test_salaries, get_wage)
str(test_salaries)  # Vérifiez que c'est bien un vecteur de chaînes
get_wage = function(line) {
print(paste("Input:", line))  # Debug: Imprimez l'entrée
# Vérifier si la ligne est non vide
wage <- line
if (is.na(wage) || wage == "") {
print("Empty or NA input, returning NA")
return(NA_real_)
}
# Nettoyer le texte du salaire
wage <- gsub(" ", "", wage)        # Supprimer les espaces
print(paste("Cleaned wage:", wage))
wage <- gsub(",", ".", wage)       # Convertir les virgules en points
print(paste("Normalized wage:", wage))
# Détecter les multiplicateurs et normaliser
multiplier <- 1
if (grepl("K", wage, ignore.case = TRUE)) {
multiplier <- 1000
wage <- gsub("[Kk]", "", wage)
print(paste("K multiplier detected, wage:", wage))
} else if (grepl("000", wage)) {
wage <- gsub("000", "", wage)
multiplier <- 1000
print(paste("000 multiplier detected, wage:", wage))
}
# Extraire les nombres
numbers <- as.numeric(unlist(str_extract_all(wage, "\\d+\\.?\\d*")))
print(paste("Extracted numbers:", paste(numbers, collapse = ", ")))
if (length(numbers) == 0 || any(is.na(numbers))) {
print("No valid numbers found, returning NA")
return(NA_real_)
}
# Calculer la moyenne en cas de fourchette
avg_wage <- mean(numbers) * multiplier
# Ajuster pour les périodes (jour, mois, semaine)
if (str_detect(wage, "\\bjour\\b")) {
avg_wage <- avg_wage * 365
} else if (str_detect(wage, "\\bmois\\b")) {
avg_wage <- avg_wage * 12
} else if (str_detect(wage, "\\bsemaine\\b")) {
avg_wage <- avg_wage * 52
}
print(paste("Final average wage:", avg_wage))
# Retourner avec 2 décimales
return(round(avg_wage, 2))
}
test_salaries <- c("50K", "20 000", "30k par mois", "15000-20000", "200 par jour", "", NA, "invalid text")
str(test_salaries)  # Vérifiez que c'est bien un vecteur de chaînes
sapply(test_salaries, get_wage)
str_detect("200 par jour", "\\bjour\\b")
get_wage = function(line) {
print(paste("Input:", line))  # Debug: Imprimez l'entrée
# Vérifier si la ligne est non vide
wage <- line
if (is.na(wage) || wage == "") {
print("Empty or NA input, returning NA")
return(NA_real_)
}
# Nettoyer le texte du salaire
wage <- gsub(" ", "", wage)        # Supprimer les espaces
print(paste("Cleaned wage:", wage))
wage <- gsub(",", ".", wage)       # Convertir les virgules en points
print(paste("Normalized wage:", wage))
# Détecter les multiplicateurs et normaliser
multiplier <- 1
if (grepl("K", wage, ignore.case = TRUE)) {
multiplier <- 1000
wage <- gsub("[Kk]", "", wage)
print(paste("K multiplier detected, wage:", wage))
} else if (grepl("000", wage)) {
wage <- gsub("000", "", wage)
multiplier <- 1000
print(paste("000 multiplier detected, wage:", wage))
}
# Extraire les nombres
numbers <- as.numeric(unlist(str_extract_all(wage, "\\d+\\.?\\d*")))
print(paste("Extracted numbers:", paste(numbers, collapse = ", ")))
if (length(numbers) == 0 || any(is.na(numbers))) {
print("No valid numbers found, returning NA")
return(NA_real_)
}
# Calculer la moyenne en cas de fourchette
avg_wage <- mean(numbers) * multiplier
print(wage)
# Ajuster pour les périodes (jour, mois, semaine)
if (str_detect(wage, "\\bjour\\b")) {
avg_wage <- avg_wage * 365
} else if (str_detect(wage, "\\bmois\\b")) {
avg_wage <- avg_wage * 12
} else if (str_detect(wage, "\\bsemaine\\b")) {
avg_wage <- avg_wage * 52
}
print(paste("Final average wage:", avg_wage))
# Retourner avec 2 décimales
return(round(avg_wage, 2))
}
test_salaries <- c("50K", "20 000", "30k par mois", "15000-20000", "200 par jour", "", NA, "invalid text")
str(test_salaries)  # Vérifiez que c'est bien un vecteur de chaînes
sapply(test_salaries, get_wage)
str_detect("200parjour", "\\bjour\\b")
str_detect("200parjour", "jour")
# Retourner avec 2 décimales
return(round(avg_wage, 2))
get_wage = function(line) {
print(paste("Input:", line))  # Debug: Imprimez l'entrée
# Vérifier si la ligne est non vide
wage <- line
if (is.na(wage) || wage == "") {
print("Empty or NA input, returning NA")
return(NA_real_)
}
# Nettoyer le texte du salaire
wage <- gsub(" ", "", wage)        # Supprimer les espaces
print(paste("Cleaned wage:", wage))
wage <- gsub(",", ".", wage)       # Convertir les virgules en points
print(paste("Normalized wage:", wage))
# Détecter les multiplicateurs et normaliser
multiplier <- 1
if (grepl("K", wage, ignore.case = TRUE)) {
multiplier <- 1000
wage <- gsub("[Kk]", "", wage)
print(paste("K multiplier detected, wage:", wage))
} else if (grepl("000", wage)) {
wage <- gsub("000", "", wage)
multiplier <- 1000
print(paste("000 multiplier detected, wage:", wage))
}
# Extraire les nombres
numbers <- as.numeric(unlist(str_extract_all(wage, "\\d+\\.?\\d*")))
print(paste("Extracted numbers:", paste(numbers, collapse = ", ")))
if (length(numbers) == 0 || any(is.na(numbers))) {
print("No valid numbers found, returning NA")
return(NA_real_)
}
# Calculer la moyenne en cas de fourchette
avg_wage <- mean(numbers) * multiplier
print(wage)
# Ajuster pour les périodes (jour, mois, semaine)
if (str_detect(wage, "jour")) {
avg_wage <- avg_wage * 365
} else if (str_detect(wage, "mois")) {
avg_wage <- avg_wage * 12
} else if (str_detect(wage, "semaine")) {
avg_wage <- avg_wage * 52
}
print(paste("Final average wage:", avg_wage))
# Retourner avec 2 décimales
return(round(avg_wage, 2))
}
test_salaries <- c("50K", "20 000", "30k par mois", "15000-20000", "200 par jour", "", NA, "invalid text")
str(test_salaries)  # Vérifiez que c'est bien un vecteur de chaînes
sapply(test_salaries, get_wage)
View(offres)
View(offres)
# Apply the salary processing function
offres[, avg_wage := sapply(salaire, get_wage)]
# Libraries
source("smams_src_utilities.R")
library(data.table)
library(stringr)
# Importation des données
# Champs: intitule_poste entreprise type_emploi secteur experience_requise competences_requises poste_desc salaire departement"
#
# --> Création de `offres` contenant les données suivantes:
#     entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
data = data.table(read.csv(file = "Data/emp_offers_fmt.tsv", # Importation
head = TRUE,
sep = ","))
# changement
offres <- data[, .(entreprise, secteur, experience_requise, competences_requises, salaire, departement)]
# Apply the salary processing function
offres[, avg_wage := sapply(salaire, get_wage)]
# Clean competences_requises column before grouping
offres[, competences_requises := sapply(competences_requises, clean_competences)]
# Group by firm_name, and calculate all other columns
base_emp = offres[, .(
firm_name = set_firm_name(entreprise),                      # Firm name
n_offres = .N,                                              # Number of offers
sector_main = get_top_val(secteur, 4), # Flattened and top 4 sectors
avg_req_exp = round(sum(experience_requise, na.rm = TRUE) / sum(!is.na(experience_requise)), 1), # Average experience, round 1
# avg_wage = 0,
avg_wage = mean(avg_wage, na.rm = TRUE),                     # Average annual salary
addr_dept_main = get_top_val(departement, 1),  # Most common department
top_skill_req = get_top_val(competences_requises, 4)  # Top 4 most frequent skills
), by = entreprise]
# Remove the "entreprise" column and rename grouped by "firm_name"
base_emp[, entreprise := NULL]
# Print the final grouped results
View(base_emp)
head(base_emp)
######################################################
# Problèmes: wage_avg ne s'applique pas correctement sur les premières lignes
# Suppression des anciennes colonnes
# A faire (voir plus bas)
# Aggrégation
# A faire (voir plus bas)
# Application des fonctions
# A faire (voir plus bas)
# Nettoyage manuel
# A faire (voir plus bas)
# Schéma à suivre:
#
# Appliquer les fonctions : (fait, voir problèmes ci-dessus)
#   - get_id_firm sur entreprise pour construire la colonne id_firm
#   - get_skills sur secteur, competences_requises, pour construire les colonnes sector_name, top_skill_req
#   - get_wage sur salaire pour construire la colonne avg_wage
# Initialiser:
#   - firm_name sur entreprise
#   - n_offres à 1
#   - avg_req_exp à experience_requise
#   - addre_dept_main à departement
#
# Supprimer les colonnes entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
# Aggréger selon id_firm en fusionnant:
#   - Concaténation des listes sur firm_name, sector_name, top_skill_req, addre_dept_main
#   - Somme des numerics sur n_offres
#   - Moyenne des valeurs sur avg_req_exp, avg_wage
#
# Appliquer les fonctions:
#   - get_top_val sur la colonne firm_name, sector_name, top_skill_req, addre_dept_main
#
# Libraries
source("smams_src_utilities.R")
library(data.table)
library(stringr)
# Importation des données
# Champs: intitule_poste entreprise type_emploi secteur experience_requise competences_requises poste_desc salaire departement"
#
# --> Création de `offres` contenant les données suivantes:
#     entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
data = data.table(read.csv(file = "Data/emp_offers_fmt.tsv", # Importation
head = TRUE,
sep = ","))
# changement
offres <- data[, .(entreprise, secteur, experience_requise, competences_requises, salaire, departement)]
# Apply the salary processing function
offres[, avg_wage := sapply(salaire, get_wage)]
# Clean competences_requises column before grouping
offres[, competences_requises := sapply(competences_requises, clean_competences)]
# Group by firm_name, and calculate all other columns
base_emp = offres[, .(
firm_name = set_firm_name(entreprise),                      # Firm name
n_offres = .N,                                              # Number of offers
sector_main = get_top_val(secteur, 4), # Flattened and top 4 sectors
avg_req_exp = round(sum(experience_requise, na.rm = TRUE) / sum(!is.na(experience_requise)), 1), # Average experience, round 1
# avg_wage = 0,
avg_wage = mean(avg_wage, na.rm = TRUE),                     # Average annual salary
addr_dept_main = get_top_val(departement, 1),  # Most common department
top_skill_req = get_top_val(competences_requises, 4)  # Top 4 most frequent skills
), by = entreprise]
# Remove the "entreprise" column and rename grouped by "firm_name"
base_emp[, entreprise := NULL]
# Print the final grouped results
View(base_emp)
head(base_emp)
######################################################
# Problèmes: wage_avg ne s'applique pas correctement sur les premières lignes
# Suppression des anciennes colonnes
# A faire (voir plus bas)
# Aggrégation
# A faire (voir plus bas)
# Application des fonctions
# A faire (voir plus bas)
# Nettoyage manuel
# A faire (voir plus bas)
# Schéma à suivre:
#
# Appliquer les fonctions : (fait, voir problèmes ci-dessus)
#   - get_id_firm sur entreprise pour construire la colonne id_firm
#   - get_skills sur secteur, competences_requises, pour construire les colonnes sector_name, top_skill_req
#   - get_wage sur salaire pour construire la colonne avg_wage
# Initialiser:
#   - firm_name sur entreprise
#   - n_offres à 1
#   - avg_req_exp à experience_requise
#   - addre_dept_main à departement
#
# Supprimer les colonnes entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
# Aggréger selon id_firm en fusionnant:
#   - Concaténation des listes sur firm_name, sector_name, top_skill_req, addre_dept_main
#   - Somme des numerics sur n_offres
#   - Moyenne des valeurs sur avg_req_exp, avg_wage
#
# Appliquer les fonctions:
#   - get_top_val sur la colonne firm_name, sector_name, top_skill_req, addre_dept_main
#
View(base_emp)
View(data)
rm(*)
rm(*)
rm(base_emp, data, offres, offres_grouped)
# Libraries
source("smams_src_utilities.R")
library(data.table)
library(stringr)
# Importation des données
# Champs: intitule_poste entreprise type_emploi secteur experience_requise competences_requises poste_desc salaire departement"
#
# --> Création de `offres` contenant les données suivantes:
#     entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
data = data.table(read.csv(file = "Data/emp_offers_fmt.tsv", # Importation
head = TRUE,
sep = ","))
# changement
offres <- data[, .(entreprise, secteur, experience_requise, competences_requises, salaire, departement)]
# Apply the salary processing function
offres[, avg_wage := sapply(salaire, get_wage)]
# Clean competences_requises column before grouping
offres[, competences_requises := sapply(competences_requises, clean_competences)]
# Group by firm_name, and calculate all other columns
base_emp = offres[, .(
firm_name = set_firm_name(entreprise),                      # Firm name
n_offres = .N,                                              # Number of offers
sector_main = get_top_val(secteur, 4), # Flattened and top 4 sectors
avg_req_exp = round(sum(experience_requise, na.rm = TRUE) / sum(!is.na(experience_requise)), 1), # Average experience, round 1
# avg_wage = 0,
avg_wage = mean(avg_wage, na.rm = TRUE),                     # Average annual salary
addr_dept_main = get_top_val(departement, 1),  # Most common department
top_skill_req = get_top_val(competences_requises, 4)  # Top 4 most frequent skills
), by = entreprise]
# Remove the "entreprise" column and rename grouped by "firm_name"
base_emp[, entreprise := NULL]
# Print the final grouped results
View(base_emp)
head(base_emp)
######################################################
# Problèmes: wage_avg ne s'applique pas correctement sur les premières lignes
# Suppression des anciennes colonnes
# A faire (voir plus bas)
# Aggrégation
# A faire (voir plus bas)
# Application des fonctions
# A faire (voir plus bas)
# Nettoyage manuel
# A faire (voir plus bas)
# Schéma à suivre:
#
# Appliquer les fonctions : (fait, voir problèmes ci-dessus)
#   - get_id_firm sur entreprise pour construire la colonne id_firm
#   - get_skills sur secteur, competences_requises, pour construire les colonnes sector_name, top_skill_req
#   - get_wage sur salaire pour construire la colonne avg_wage
# Initialiser:
#   - firm_name sur entreprise
#   - n_offres à 1
#   - avg_req_exp à experience_requise
#   - addre_dept_main à departement
#
# Supprimer les colonnes entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
# Aggréger selon id_firm en fusionnant:
#   - Concaténation des listes sur firm_name, sector_name, top_skill_req, addre_dept_main
#   - Somme des numerics sur n_offres
#   - Moyenne des valeurs sur avg_req_exp, avg_wage
#
# Appliquer les fonctions:
#   - get_top_val sur la colonne firm_name, sector_name, top_skill_req, addre_dept_main
#
View(data)
View(data)
View(data)
View(data)
View(data)
# Libraries
source("smams_src_utilities.R")
library(data.table)
library(stringr)
# Importation des données
# Champs: intitule_poste entreprise type_emploi secteur experience_requise competences_requises poste_desc salaire departement"
#
# --> Création de `offres` contenant les données suivantes:
#     entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
data = data.table(read.csv(file = "Data/emp_offers_fmt.tsv", # Importation
head = TRUE,
sep = ","))
# changement
offres <- data[, .(entreprise, secteur, experience_requise, competences_requises, salaire, departement)]
# Apply the salary processing function
offres[, avg_wage := sapply(salaire, get_wage)]
# Clean competences_requises column before grouping
offres[, competences_requises := sapply(competences_requises, clean_competences)]
# Group by firm_name, and calculate all other columns
base_emp = offres[, .(
firm_name = set_firm_name(entreprise),                      # Firm name
n_offres = .N,                                              # Number of offers
sector_main = get_top_val(secteur, 4), # Flattened and top 4 sectors
avg_req_exp = round(sum(experience_requise, na.rm = TRUE) / sum(!is.na(experience_requise)), 1), # Average experience, round 1
# avg_wage = 0,
avg_wage = mean(avg_wage, na.rm = TRUE),                     # Average annual salary
addr_dept_main = get_top_val(departement, 1),  # Most common department
top_skill_req = get_top_val(competences_requises, 4)  # Top 4 most frequent skills
), by = entreprise]
# Remove the "entreprise" column and rename grouped by "firm_name"
base_emp[, entreprise := NULL]
# Print the final grouped results
View(base_emp)
head(base_emp)
######################################################
# Problèmes: wage_avg ne s'applique pas correctement sur les premières lignes
# Suppression des anciennes colonnes
# A faire (voir plus bas)
# Aggrégation
# A faire (voir plus bas)
# Application des fonctions
# A faire (voir plus bas)
# Nettoyage manuel
# A faire (voir plus bas)
# Schéma à suivre:
#
# Appliquer les fonctions : (fait, voir problèmes ci-dessus)
#   - get_id_firm sur entreprise pour construire la colonne id_firm
#   - get_skills sur secteur, competences_requises, pour construire les colonnes sector_name, top_skill_req
#   - get_wage sur salaire pour construire la colonne avg_wage
# Initialiser:
#   - firm_name sur entreprise
#   - n_offres à 1
#   - avg_req_exp à experience_requise
#   - addre_dept_main à departement
#
# Supprimer les colonnes entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
# Aggréger selon id_firm en fusionnant:
#   - Concaténation des listes sur firm_name, sector_name, top_skill_req, addre_dept_main
#   - Somme des numerics sur n_offres
#   - Moyenne des valeurs sur avg_req_exp, avg_wage
#
# Appliquer les fonctions:
#   - get_top_val sur la colonne firm_name, sector_name, top_skill_req, addre_dept_main
#
View(data)
View(data)
# Libraries
source("smams_src_utilities.R")
library(data.table)
library(stringr)
# Importation des données
# Champs: intitule_poste entreprise type_emploi secteur experience_requise competences_requises poste_desc salaire departement"
#
# --> Création de `offres` contenant les données suivantes:
#     entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
data = data.table(read.csv(file = "Data/emp_offers_fmt.tsv", # Importation
head = TRUE,
sep = ","))
# changement
offres <- data[, .(entreprise, secteur, experience_requise, competences_requises, salaire, departement)]
# Apply the salary processing function
offres[, avg_wage := sapply(salaire, get_wage)]
# Clean competences_requises column before grouping
offres[, competences_requises := sapply(competences_requises, clean_competences)]
# Group by firm_name, and calculate all other columns
base_emp = offres[, .(
firm_name = set_firm_name(entreprise),                      # Firm name
n_offres = .N,                                              # Number of offers
sector_main = get_top_val(secteur, 4), # Flattened and top 4 sectors
avg_req_exp = round(sum(experience_requise, na.rm = TRUE) / sum(!is.na(experience_requise)), 1), # Average experience, round 1
# avg_wage = 0,
avg_wage = mean(avg_wage, na.rm = TRUE),                     # Average annual salary
addr_dept_main = get_top_val(departement, 1),  # Most common department
top_skill_req = get_top_val(competences_requises, 4)  # Top 4 most frequent skills
), by = entreprise]
# Remove the "entreprise" column and rename grouped by "firm_name"
base_emp[, entreprise := NULL]
# Print the final grouped results
View(base_emp)
head(base_emp)
######################################################
# Problèmes: wage_avg ne s'applique pas correctement sur les premières lignes
# Suppression des anciennes colonnes
# A faire (voir plus bas)
# Aggrégation
# A faire (voir plus bas)
# Application des fonctions
# A faire (voir plus bas)
# Nettoyage manuel
# A faire (voir plus bas)
# Schéma à suivre:
#
# Appliquer les fonctions : (fait, voir problèmes ci-dessus)
#   - get_id_firm sur entreprise pour construire la colonne id_firm
#   - get_skills sur secteur, competences_requises, pour construire les colonnes sector_name, top_skill_req
#   - get_wage sur salaire pour construire la colonne avg_wage
# Initialiser:
#   - firm_name sur entreprise
#   - n_offres à 1
#   - avg_req_exp à experience_requise
#   - addre_dept_main à departement
#
# Supprimer les colonnes entreprise, secteur, experience_requise, competences_requises, salaire, departement
#
# Aggréger selon id_firm en fusionnant:
#   - Concaténation des listes sur firm_name, sector_name, top_skill_req, addre_dept_main
#   - Somme des numerics sur n_offres
#   - Moyenne des valeurs sur avg_req_exp, avg_wage
#
# Appliquer les fonctions:
#   - get_top_val sur la colonne firm_name, sector_name, top_skill_req, addre_dept_main
#
